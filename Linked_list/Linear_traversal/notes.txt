Linked List Linear Traversal Pattern

What is Linear Traversal?
Linear traversal is the fundamental technique of visiting each node in a linked list exactly once, moving from one node to the next through the next pointer, processing data as you go.
Think of it like reading a book page by page - you start at the beginning and move forward sequentially until you reach the end.

Core Concept:
# Basic Linear Traversal Template
def traverse(head):
    current = head
    while current:
        # Process current node
        print(current.data)
        # Move to next node
        current = current.next

Key Elements:
> Starting Point - Usually the head node
> Iteration Condition - while current: (stop when None)
> Processing - Do something with current.data
> Movement - current = current.next

Pattern Variations
1. Single Pointer Traversal
Most basic pattern - one pointer moving through the list.
def count_nodes(head):
    """Count total nodes in linked list"""
    current = head
    count = 0
    while current:
        count += 1
        current = current.next
    return count

# Time: O(n), Space: O(1)
When to use: Counting, searching, displaying, accumulating values

2. Previous-Current Pattern
Track both current and previous nodes for operations requiring context.
def delete_node_with_value(head, target):
    """Delete first node with target value"""
    # Special case: delete head
    if head and head.data == target:
        return head.next
    
    prev = None
    current = head
    
    while current:
        if current.data == target:
            prev.next = current.next  # Remove current
            return head
        prev = current
        current = current.next
    
    return head

# Time: O(n), Space: O(1)
When to use: Deletion, insertion after specific node, swapping

3. Dummy Node Pattern
Use a dummy/sentinel node to simplify edge cases.
def remove_elements(head, val):
    """Remove all nodes with specific value"""
    dummy = Node(0)
    dummy.next = head
    
    prev = dummy
    current = head
    
    while current:
        if current.data == val:
            prev.next = current.next
        else:
            prev = current
        current = current.next
    
    return dummy.next

# Time: O(n), Space: O(1)
When to use: Operations that might modify head, merge operations

4. Two Pointer (Slow-Fast)
Two pointers moving at different speeds.
def find_middle(head):
    """Find middle node - slow/fast technique"""
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next        # Move 1 step
        fast = fast.next.next   # Move 2 steps
    
    return slow  # Slow is at middle when fast reaches end

# Time: O(n), Space: O(1)
When to use: Finding middle, cycle detection, nth from end

5. Two Pointer with Gap
Two pointers with fixed distance between them.
def remove_nth_from_end(head, n):
    """Remove nth node from end"""
    dummy = Node(0)
    dummy.next = head
    first = second = dummy
    
    # Move first pointer n+1 steps ahead
    for _ in range(n + 1):
        first = first.next
    
    # Move both until first reaches end
    while first:
        first = first.next
        second = second.next
    
    # Remove the node
    second.next = second.next.next
    return dummy.next

# Time: O(n), Space: O(1)
When to use: Operations from end, finding kth from end


6. Runner Technique
One pointer moves ahead to gather information.
def is_palindrome(head):
    """Check if linked list is palindrome"""
    # Find middle using slow-fast
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    prev = None
    while slow:
        next_node = slow.next
        slow.next = prev
        prev = slow
        slow = next_node
    
    # Compare both halves
    left, right = head, prev
    while right:  # Right half might be shorter
        if left.data != right.data:
            return False
        left = left.next
        right = right.next
    
    return True

# Time: O(n), Space: O(1)
When to use: Palindrome check, reordering operations

Problem-Solving Techniques
Technique 1: Accumulation During Traversal
Problem: Sum all node values
def sum_list(head):
    total = 0
    current = head
    while current:
        total += current.data
        current = current.next
    return total


Problem: Convert binary linked list to integer
def binary_to_decimal(head):
    """LeetCode 1290"""
    result = 0
    current = head
    while current:
        result = result * 2 + current.data  # Shift left and add
        current = current.next
    return result

# Example: 1 -> 0 -> 1
# Step 1: 0 * 2 + 1 = 1
# Step 2: 1 * 2 + 0 = 2
# Step 3: 2 * 2 + 1 = 5

Technique 2: Conditional Processing
Problem: Remove duplicates from sorted list (LeetCode 83)
def delete_duplicates(head):
    current = head
    
    while current and current.next:
        if current.data == current.next.data:
            # Skip duplicate
            current.next = current.next.next
        else:
            # Move to next unique value
            current = current.next
    
    return head

# Example: 1 -> 1 -> 2 -> 3 -> 3
# Result:  1 -> 2 -> 3

Problem: Remove all elements with value (LeetCode 203)
def remove_elements(head, val):
    dummy = Node(0)
    dummy.next = head
    current = dummy
    
    while current.next:
        if current.next.data == val:
            current.next = current.next.next
        else:
            current = current.next
    
    return dummy.next


Technique 3: Multi-Pass Traversal
Problem: Rotate list right by k (LeetCode 61)
def rotate_right(head, k):
    if not head or not head.next or k == 0:
        return head
    
    # First pass: Find length and connect to make circular
    length = 1
    tail = head
    while tail.next:
        tail = tail.next
        length += 1
    
    tail.next = head  # Make circular
    
    # Find new tail: (length - k % length - 1) from head
    k = k % length
    steps_to_new_tail = length - k - 1
    
    new_tail = head
    for _ in range(steps_to_new_tail):
        new_tail = new_tail.next
    
    new_head = new_tail.next
    new_tail.next = None
    
    return new_head

# Example: 1->2->3->4->5, k=2
# Result:  4->5->1->2->3

Technique 4: Partition Strategy
Problem: Odd Even Linked List (LeetCode 328)
def odd_even_list(head):
    if not head or not head.next:
        return head
    
    odd = head
    even = head.next
    even_head = even
    
    # Traverse and partition
    while even and even.next:
        odd.next = even.next
        odd = odd.next
        even.next = odd.next
        even = even.next
    
    # Connect odd list to even list
    odd.next = even_head
    return head

# Example: 1->2->3->4->5
# Result:  1->3->5->2->4

Problem: Partition List (LeetCode 86)
def partition(head, x):
    # Two separate lists
    less_head = less = Node(0)
    greater_head = greater = Node(0)
    
    current = head
    while current:
        if current.data < x:
            less.next = current
            less = less.next
        else:
            greater.next = current
            greater = greater.next
        current = current.next
    
    greater.next = None  # Important: break cycles
    less.next = greater_head.next
    
    return less_head.next

# Example: 1->4->3->2->5->2, x=3
# Result:  1->2->2->4->3->5

Technique 5: Reversal During Traversal
Problem: Reverse Linked List (LeetCode 206)
def reverse_list(head):
    prev = None
    current = head
    
    while current:
        next_node = current.next  # Save next
        current.next = prev       # Reverse pointer
        prev = current            # Move prev forward
        current = next_node       # Move current forward
    
    return prev

# Visualization:
# Initial:  1 -> 2 -> 3 -> None
# Step 1:   None <- 1   2 -> 3 -> None
# Step 2:   None <- 1 <- 2   3 -> None
# Step 3:   None <- 1 <- 2 <- 3

Problem: Reverse Between Positions (LeetCode 92)
def reverse_between(head, left, right):
    if left == right:
        return head
    
    dummy = Node(0)
    dummy.next = head
    prev = dummy
    
    # Move to position before left
    for _ in range(left - 1):
        prev = prev.next
    
    # Reverse from left to right
    current = prev.next
    for _ in range(right - left):
        next_node = current.next
        current.next = next_node.next
        next_node.next = prev.next
        prev.next = next_node
    
    return dummy.next

# Example: 1->2->3->4->5, left=2, right=4
# Result:  1->4->3->2->5

Technique 6: Merge Pattern
Problem: Merge Two Sorted Lists (LeetCode 21)
def merge_two_lists(l1, l2):
    dummy = Node(0)
    current = dummy
    
    while l1 and l2:
        if l1.data <= l2.data:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    # Attach remaining nodes
    current.next = l1 if l1 else l2
    
    return dummy.next

# Example: 1->2->4 and 1->3->4
# Result:  1->1->2->3->4->4

