Linked List
A linked list is a linear data structure that stores a sequence of elements, or "nodes," which are not stored in contiguous memory locations like arrays. Each node contains its own data and a pointer or reference to the next node in the sequence, forming a chain. This structure allows for dynamic resizing and efficient insertion and deletion of elements, though it lacks random access, requiring sequential traversal to find a specific node. 

Key characteristics
> Nodes: Each element in the list is a node, which has two main parts: the data it holds and a pointer/reference to the next node.
> Non-contiguous memory: Unlike arrays, nodes can be scattered throughout memory, as they are linked by pointers rather than being stored side-by-side.
> Dynamic size: Linked lists can grow or shrink during program execution, as new nodes can be added or removed without needing to reallocate a fixed-size block of memory.
> Head and tail: The list has a "head," which is the first node, and a "tail," which is the last node.
> Sequential access: To find a specific node, you must start at the head and follow the pointers sequentially until you reach the desired element. 

Advantages
> Efficient insertion/deletion: Adding or removing elements is often faster than with arrays because you don't need to shift other elements. You just need to update the pointers of the surrounding nodes.
> Dynamic sizing: The list can change in size as needed, making it useful for situations where the number of elements is unpredictable.
> Ease of implementation: They are a foundational structure for building other data structures like stacks and queues. 

Disadvantages
> No random access: You cannot access a node directly by its index (e.g., myList[5]). You must traverse the list from the beginning.
> Extra memory: Each node requires extra memory to store the pointer to the next node.
> Difficult reverse traversal: Traversing the list backward is not possible in a simple singly linked list and can be difficult in other types as well. 


How a Linked List Is Implemented in Python
Python doesn’t have pointers like C, but references act similarly.
A Node contains:

class Node:
  def __init__(self, data):
    self.data = data
    self.next = None

A LinkedList keeps track of the head:

class LinkedList:
  def __init__(self):
    self.head = None

When you insert new nodes, you’re just connecting references, like:
new_node.next = self.head
self.head = new_node

Key Concepts You Must Understand
> Node: A container holding data + reference
[data | next]
> Head: Pointer to the first node.
> Tail (optional): Pointer to the last node (useful for O(1) append).
> Traversal: Visiting nodes one by one starting from head.
> Null Terminator: The last node points to None.
> Dynamic Memory Allocation: Nodes are allocated as needed.

> Time Complexity
| Operation                          | Singly Linked List |
| ---------------------------------- | ------------------ |
| Access                             | O(n)               |
| Search                             | O(n)               |
| Insert at head                     | O(1)               |
| Insert at tail (no tail pointer)   | O(n)               |
| Insert at tail (with tail pointer) | O(1)               |
| Delete at head                     | O(1)               |
| Delete by value                    | O(n)               |

Types of Linked Lists
1. Singly Linked List
Each node has: data | next

2. Doubly Linked List
Each node has: prev | data | next
Allows:
✔ fast backward traversal
✔ O(1) deletion without traversal
But uses more memory.

3. Circular Linked List
Last node points back to the head: 10 -> 20 -> 30 -> (back to 10)
Good for cyclic processes (e.g., round-robin tasks).
Can be singly or doubly circular.

4. Skip List (advanced)
Multiple layers of linked lists used for fast search → O(log n) search time.
Used in databases and memory-efficient indexes.

Common Techniques You Should Learn
These come up again and again in interviews and practice:
1. Fast and Slow Pointer Technique
Used for:
  - Detecting cycles (Floyd’s algorithm)
  - Finding middle of list
  - Checking palindrome
  - Removing nth node from end
Pattern:
slow = fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next


2. Reversing a Linked List
Classic interview question.
A -> B -> C -> None
Becomes:
C -> B -> A
Using iterative pointers:
  - prev
  - curr
  - next_temp

4. Merge Two Sorted Lists
Used heavily in merge sort.

5. Recursion for Linked Lists
Used for:
  - reverse
  - printing in reverse
  - merge operations


When Should You Use Linked Lists?
Realistically:
✔ When you have many insertions/deletions at the beginning
✔ When memory allocation is unpredictable
✔ When you build stacks, queues, adjacency lists
✔ When designing LRU cache (uses doubly linked list + hashmap)
✔ For simulating continuous data streams
You should not use them for indexing-heavy work.

Where Linked Lists Are Used in Real Life
Practical use cases:
> Music playlists (next/previous)
> Photo viewers
> Undo/redo operations
> Browser history
> HashMap chaining (collision handling)
> OS scheduling (round-robin using circular lists)
> LRU cache (doubly linked list)

Your Learning Path (Recommended)
Here’s how to master linked lists step by step:
Step 1: Learn basics
✔ Node
✔ Insertion (front, end, index)
✔ Deletion (front, end, index, by value)
Step 2: Learn traversal
✔ Print
✔ Length
✔ Search
Step 3: Core patterns
✔ Reverse
✔ Fast/slow pointer
✔ Merge lists
✔ Detect cycle
✔ Remove cycle
Step 4: Intermediate
✔ Doubly linked list
✔ Circular list
Step 5: Advanced
✔ LRU cache
✔ Skip list
✔ Memory-efficient linked lists
