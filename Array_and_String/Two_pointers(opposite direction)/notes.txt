Two Pointers (Opposite Direction) Pattern in Python
Overview
The Two Pointers (Opposite Direction) pattern uses two pointers that start from opposite ends of a data structure (usually an array or string) and move towards each other. This technique is particularly useful for problems involving pairs, palindromes, or reversing operations.

Core Concept
def two_pointers_template(arr):
    left = 0
    right = len(arr) - 1
    
    while left < right:
        # Process elements at left and right
        # Make decision based on comparison
        
        # Move pointers based on condition
        if condition:
            left += 1
        else:
            right -= 1
    
    return result

Key Characteristics
> Time Complexity: O(n) - Each element visited at most once
> Space Complexity: O(1) - Only uses two pointers
> When to Use: Sorted arrays, palindrome checks, pair finding, reversing

Common Techniques
1. Pair Sum in Sorted Array
Find two numbers that add up to a target.
def two_sum_sorted(nums, target):
    """
    Find pair that sums to target in sorted array
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        current_sum = nums[left] + nums[right]
        
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1  # Need larger sum
        else:
            right -= 1  # Need smaller sum
    
    return [-1, -1]

# Example
print(two_sum_sorted([2, 7, 11, 15], 9))  # [0, 1]
print(two_sum_sorted([1, 2, 3, 4, 6], 6))  # [1, 3]


2. Palindrome Verification
Check if a string is a palindrome.
def is_palindrome(s):
    """
    Check if string is palindrome (ignoring non-alphanumeric)
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric characters
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        # Compare characters (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True

# Examples
print(is_palindrome("A man, a plan, a canal: Panama"))  # True
print(is_palindrome("race a car"))  # False


3. Reverse Array/String
Reverse elements in-place.
def reverse_array(arr):
    """
    Reverse array in-place
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(arr) - 1
    
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    
    return arr

# Example
print(reverse_array([1, 2, 3, 4, 5]))  # [5, 4, 3, 2, 1]

4. Container With Most Water
Find maximum area between two lines.
def max_area(height):
    """
    Find container with most water
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        # Calculate current area
        width = right - left
        current_height = min(height[left], height[right])
        current_area = width * current_height
        max_water = max(max_water, current_area)
        
        # Move pointer with smaller height
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_water

# Example
print(max_area([1,8,6,2,5,4,8,3,7]))  # 49

5. Three Sum (Extension)
Find triplets that sum to zero.
def three_sum(nums):
    """
    Find all unique triplets that sum to zero
    Time: O(nÂ²), Space: O(1) excluding output
    """
    nums.sort()
    result = []
    
    for i in range(len(nums) - 2):
        # Skip duplicates for first number
        if i > 0 and nums[i] == nums[i-1]:
            continue
        
        # Two pointers for remaining elements
        left, right = i + 1, len(nums) - 1
        target = -nums[i]
        
        while left < right:
            current_sum = nums[left] + nums[right]
            
            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    
    return result

# Example
print(three_sum([-1, 0, 1, 2, -1, -4]))  # [[-1, -1, 2], [-1, 0, 1]]

6. Remove Duplicates from Sorted Array
Remove duplicates in-place and return new length.
def remove_duplicates(nums):
    """
    Remove duplicates in-place from sorted array
    Time: O(n), Space: O(1)
    """
    if not nums:
        return 0
    
    write_ptr = 1  # Position to write next unique element
    
    for read_ptr in range(1, len(nums)):
        if nums[read_ptr] != nums[read_ptr - 1]:
            nums[write_ptr] = nums[read_ptr]
            write_ptr += 1
    
    return write_ptr

# Example
nums = [1, 1, 2, 2, 3, 4, 4]
length = remove_duplicates(nums)
print(nums[:length])  # [1, 2, 3, 4]

7. Trapping Rain Water
Calculate trapped rainwater between bars.
def trap(height):
    """
    Calculate trapped rainwater
    Time: O(n), Space: O(1)
    """
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max, right_max = 0, 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    
    return water

# Example
print(trap([0,1,0,2,1,0,1,3,2,1,2,1]))  # 6


LeetCode Problems Pattern Recognition
Easy Problems
1. Valid Palindrome (LC 125) - Basic two pointers
2. Reverse String (LC 344) - Simple swap
3. Two Sum II (LC 167) - Sorted array pair sum
4. Merge Sorted Array (LC 88) - Merge from end

Medium Problems
1. Container With Most Water (LC 11) - Maximize area
2. 3Sum (LC 15) - Triple nested with optimization
3. Sort Colors (LC 75) - Dutch National Flag
4. Remove Duplicates II (LC 80) - Allow k duplicates
5. Rotate Array (LC 189) - Multiple reversals
6. Next Permutation (LC 31) - Find pivot and reverse

Hard Problems
1. Trapping Rain Water (LC 42) - Track max heights
2. Minimum Window Substring (LC 76) - Sliding + two pointers


Step-by-Step Problem Solving Approach
Step 1: Identify the Pattern
Ask yourself:
> Is the array/string sorted or can it be sorted?
> Am I looking for pairs or comparing elements from ends?
> Do I need to verify symmetry (palindrome)?
> Can I make greedy decisions from both ends?

Step 2: Setup Pointers
left = 0
right = len(array) - 1

Step 3: Define Loop Condition
while left < right:  # Most common
# OR
while left <= right:  # When middle element matters

Step 4: Process Logic
# Compare or calculate
result = process(arr[left], arr[right])

# Make decision
if condition:
    # Move appropriate pointer
    left += 1
else:
    right -= 1

Step 5: Handle Edge Cases
- Empty array
- Single element
- All same elements
- No valid answer

Common Pitfalls to Avoid
> Off-by-one errors: Be careful with left < right vs left <= right
> Forgetting to move pointers: Infinite loop if pointers don't move
> Not handling duplicates: In problems like 3Sum
> Modifying while iterating: Use separate read/write pointers
> Assuming sorted input: Check problem constraints

Practice Strategy
> Master basics: Start with palindrome and reverse problems
> Add complexity: Move to pair sum variations
> Combine techniques: Try 3Sum, 4Sum with sorting
> Optimize: Practice space-efficient solutions
> Handle edge cases: Test with empty, single element, duplicates
