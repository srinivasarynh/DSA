Monotonic Stack Pattern
Core Concept
A monotonic stack is a stack data structure that maintains elements in either monotonically increasing or monotonically decreasing order. When adding a new element, we remove elements from the top of the stack that violate the monotonic property.

Two types:
> Monotonically Increasing Stack: Each element is greater than or equal to the one below it (bottom to top)
> Monotonically Decreasing Stack: Each element is less than or equal to the one below it (bottom to top)

Why Use Monotonic Stack?
Monotonic stacks excel at solving problems involving:
> Finding the next greater/smaller element
> Finding the previous greater/smaller element
> Problems requiring range queries with min/max constraints
> Histogram-like problems
> Temperature/stock span type problems

Time Complexity: O(n) - each element is pushed and popped at most once
Space Complexity: O(n) - stack storage

Key Techniques
1. Next Greater Element (NGE)
Use a monotonically decreasing stack (stores indices or values in decreasing order from bottom to top).
def next_greater_element(nums):
    n = len(nums)
    result = [-1] * n
    stack = []  # stores indices
    
    for i in range(n):
        # Pop elements smaller than current
        while stack and nums[stack[-1]] < nums[i]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result

# Example: [2, 1, 2, 4, 3]
# Result:  [4, 2, 4, -1, -1]

2. Next Smaller Element (NSE)
Use a monotonically increasing stack.
def next_smaller_element(nums):
    n = len(nums)
    result = [-1] * n
    stack = []
    
    for i in range(n):
        # Pop elements greater than current
        while stack and nums[stack[-1]] > nums[i]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result

# Example: [4, 2, 1, 5, 3]
# Result:  [2, 1, -1, 3, -1]

3. Previous Greater/Smaller Element
Iterate from left to right and check stack top directly.
def previous_greater_element(nums):
    result = [-1] * len(nums)
    stack = []  # decreasing stack
    
    for i in range(len(nums)):
        # Maintain decreasing order
        while stack and nums[stack[-1]] <= nums[i]:
            stack.pop()
        
        if stack:
            result[i] = nums[stack[-1]]
        
        stack.append(i)
    
    return result


4. Circular Array Pattern
Iterate through array twice (or use modulo).
def next_greater_circular(nums):
    n = len(nums)
    result = [-1] * n
    stack = []
    
    # Iterate twice
    for i in range(2 * n):
        idx = i % n
        while stack and nums[stack[-1]] < nums[idx]:
            result[stack.pop()] = nums[idx]
        
        if i < n:  # Only push in first iteration
            stack.append(idx)
    
    return result

Template Pattern
def monotonic_stack_template(nums):
    stack = []  # stores indices or values
    result = [default_value] * len(nums)
    
    for i in range(len(nums)):
        # Maintain monotonic property
        while stack and condition(stack[-1], i):
            idx = stack.pop()
            result[idx] = compute(i)  # or nums[i]
        
        # Optional: check stack top for previous element
        if stack:
            result[i] = process(stack[-1])
        
        stack.append(i)
    
    return result


LeetCode Problems
Easy
496. Next Greater Element I
1047. Remove All Adjacent Duplicates In String
1441. Build an Array With Stack Operations
682. Baseball Game
735. Asteroid Collision

Medium
503. Next Greater Element II (circular array)
739. Daily Temperatures (classic monotonic stack)
901. Online Stock Span
402. Remove K Digits
456. 132 Pattern
316. Remove Duplicate Letters
321. Create Maximum Number
1019. Next Greater Node In Linked List
1130. Minimum Cost Tree From Leaf Values
1762. Buildings With an Ocean View
1673. Find the Most Competitive Subsequence
907. Sum of Subarray Minimums
2104. Sum of Subarray Ranges
2398. Maximum Number of Robots Within Budget
1944. Number of Visible People in a Queue
962. Maximum Width Ramp
1856. Maximum Subarray Min-Product
2454. Next Greater Element IV
2487. Remove Nodes From Linked List
1950. Maximum of Minimum Values in All Subarrays

Hard
84. Largest Rectangle in Histogram (classic)
85. Maximal Rectangle
42. Trapping Rain Water
32. Longest Valid Parentheses
895. Maximum Frequency Stack
1425. Constrained Subsequence Sum
2297. Jump Game VIII
2334. Subarray With Elements Greater Than Varying Threshold
2281. Sum of Total Strength of Wizards
2547. Minimum Cost to Split an Array


Detailed Examples
Example 1: Daily Temperatures (LC 739)
Problem: Given temperatures, find how many days until warmer temperature.
def dailyTemperatures(temperatures):
    n = len(temperatures)
    answer = [0] * n
    stack = []  # monotonically decreasing stack (stores indices)
    
    for i in range(n):
        # While current temp is warmer than stack top
        while stack and temperatures[stack[-1]] < temperatures[i]:
            prev_idx = stack.pop()
            answer[prev_idx] = i - prev_idx  # days difference
        
        stack.append(i)
    
    return answer

# Example: [73, 74, 75, 71, 69, 72, 76, 73]
# Result:  [1,  1,  4,  2,  1,  1,  0,  0]

Example 2: Largest Rectangle in Histogram (LC 84)
Problem: Find largest rectangular area in histogram.
def largestRectangleArea(heights):
    stack = []  # monotonically increasing stack
    max_area = 0
    heights.append(0)  # sentinel to flush stack
    
    for i in range(len(heights)):
        while stack and heights[stack[-1]] > heights[i]:
            h_idx = stack.pop()
            h = heights[h_idx]
            # Width = current index - previous bar - 1
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        
        stack.append(i)
    
    return max_area

# Example: [2, 1, 5, 6, 2, 3]
# Result: 10 (5*2 rectangle)

Example 3: Trapping Rain Water (LC 42)
Problem: Calculate trapped rainwater between bars.
def trap(height):
    stack = []  # stores indices
    water = 0
    
    for i in range(len(height)):
        while stack and height[stack[-1]] < height[i]:
            bottom = stack.pop()
            
            if not stack:
                break
            
            distance = i - stack[-1] - 1
            bounded_height = min(height[i], height[stack[-1]]) - height[bottom]
            water += distance * bounded_height
        
        stack.append(i)
    
    return water


Common Patterns Recognition
Problem Type || Stack Order || What to Store || Key Operation
Next Greater || Decreasing || Indices || Pop when smaller found
Next Smaller || Increasing || Indices || Pop when greater found
Previous Greater || Decreasing || Check top before push || Stack top is answer Histogram || Increasing || Heights/Indices || Pop when decreasing
Remove K digits || Increasing || Digits || Pop K times when smaller found

Tips for Success
> Decide monotonic direction first: Greater/smaller determines increasing/decreasing stack
> Store indices vs values: Indices give more flexibility (can calculate distances)
> Handle edge cases: Empty stack, all increasing/decreasing sequences
> Circular arrays: Iterate twice or use modulo
> Multiple passes: Sometimes need to build auxiliary arrays first
> Sentinels: Add dummy elements to simplify edge cases

The monotonic stack pattern is extremely powerful for O(n) solutions to problems that might otherwise require O(nÂ²) nested loops!
